РАЗГРАНИЧЕНИЕ ДОСТУПА

user -- пользователь системы с точки зрения системы безопасности, имеет учетную запись в таблице User.

entity -- сущность системы, таблица, говоря на SQL
instance -- конкретный экземпляр entity, запись в таблице
attributes -- набор свойств instance, поля записи в таблице

Каждый instance имеет неизменяемый уникальный атрибут ID, скрытый спецатрибут _meta для хранения истории изменений и набор обычных атрибутов

Вводятся 5 стандартных операций на сущностями:
entity.get(id) -> получить объект по его ID
entity.query(conditions) -> получить список объектов, удовлетворяющих заданным условиям
entity.add(attributes) -> создать новый объект со свойствами attibutes
entity.update(conbitions, changes) -> установить новые значения для свойств объектов, удовлетворяющих заданным условиям
entity.remove(conditions) -> удалить объекты, удовлетворяющие заданным условиям


Для обеспечения целостности логики, в этих операциях выполняются проверки входных данных. Проверка заключается в сопоставлении (validation) данных со схемой (https://github.com/dvv/json-schema). Схема описывает формат возможных данных, декларирует их обязательность, значения по умолчанию и т.п. В частности, validation в:
entity.add(attributes) ->  убирает “лишние” (не описанные в схеме, либо специально запрещенные для add) свойства, преобразует формат данных (coercion), если они не соответствуют схеме
entity.update(conbitions, changes) -> убирает не описанные либо специально запрещенные в схеме для update свойства, проверяет только те свойства, которые присутствуют в changes, преобразует формат данных (coercion), если они не соответствуют схеме


Кроме того, не описанные либо специально запрещенные в схеме для get свойства убираются при возврате данных из:
entity.get(id)
entity.query(conditions)
entity.add(attributes)


Таким образом, имеется возможность очень гибко определять какие свойства доступны при каких условиях для каждой операции над данными.

Введем обозначения для прав доступа к атрибутам:

r -- доступно в результатах entity.get()/query()
c -- возможно указание значения в параметре операции entity.add()
w -- возможно указание значения в параметре changes операции entity.update()

Опишем сущность Language для привилегированных и обычных пользователей:
		admin		user
id		cr		r
name		crw		r
…		crw		r

А вот схема для сущности Language для admin:
schema.Language =
	type: 'object'
	additionalProperties: false
	properties:
		id:
			type: 'string'
			pattern: '^[a-zA-Z0-9_]+$'
			readonly:
				update: true		# запретить изменение через update
		name:
			type: 'string'
		localName:
			type: 'string'

и для user:
schema.Language =
	type: 'object'
	additionalProperties: false
	properties:
		id:
			type: 'string'
			pattern: '^[a-zA-Z0-9_]+$'
			readonly:
				add: true			# запретить задание через add
				update: true		# запретить изменение через update
		name:
			type: 'string'
			readonly:
				add: true			# запретить задание через add
				update: true		# запретить изменение через update
		localName:
			type: 'string'
			readonly:
				add: true			# запретить задание через add
				update: true		# запретить изменение через update

Аналогично описываются другие “простые” сущности типа Region, Country, Currency, ...

ФАСЕТЫ

Для обеспечения безопасной работы системы требуется также ограничить возможности пользователей по созданию/изменению объектов. В отличие от традиционного подхода, когда права текущего пользователя проверяются каждым конкретным методом, который пользователь вызывает, применим capability-based безопасность.

При этом на основании прав текущего пользователя ему назначается динамически создаваемый контекст (facet) -- обычный объект JavaScript, свойствами которого в дальнейшем и располагает пользователь. Например, для предоставления доступа по чтению к сущности Language пользователь должен иметь “адрес” метода model.Language.query() и выражается этот так:

facet =
	Language:
		query: model.Language.query

Если такой facet дан пользователю в качестве контекста (а контекст -- единственный объект системы, доступный пользователю первоначально при выполнении запроса к системе), то пользователь не имеет никаких шансов получить другие сущности системы -- у него просто нет адресов методов доступа к ним. В традиционной системе он имел бы возможность вызывать другие методы и мог надеяться на ошибки в логике проверки прав внутри этих методов.

Используя фасеты, легко упростить схему для сущности Language, избавившись от ее специального вида для обычного пользователя.

Вот сущность Language для привилегированных и обычных пользователей:
		admin		user
id		cr		r
name		crw		r
…		crw		r

А вот схема для сущности Language уже для всех пользователей:
schema.Language =
	type: 'object'
	additionalProperties: false
	properties:
		id:
			type: 'string'
			pattern: '^[a-zA-Z0-9_]+$'
			readonly:
				update: true		# запретить изменение через update
		name:
			type: 'string'
		localName:
			type: 'string'

И фасеты для admin и user:

facet.admin =
	Language:
		query: model.Language.query
		get: model.Language.get
		add: model.Language.add
		update: model.Language.update
remove: model.Language.remove

facet.user =
	Language:
		get: model.Language.get
		query: model.Language.query

Видно, что благодаря отсутствию у обычного пользователя методов изменения для сущности Language, обычный пользователь эффективно не имеет возможности изменять свойства экземпляров Language.

Фасеты не ограничиваются методами доступа к базе данных. Например, следующий фасет вполне легален:

facet.user =
	Language:
		query: model.Language.query
	getAMisteriousData: () -> return {foo: [1, true, {bar: ‘baz’}]}

WEB-INTERFACE

Методы контекста пользователя доступны извне по протоколу HTTP в форме REST и JSON-RPC. Последний упрощен до следующего формата (здесь и далее context -- эффективный контекст текущего пользователя):

POST {jsonrpc: ‘2.0’, method: “getAMisteriousData”, params: [{foo: ‘bar’}]} вызовет context.getAMisteriousData({foo: ‘bar’}) и результат будет возвращен в виде ответа:

{jsonrpc: ‘2.0’, result:context.getAMisteriousData({foo: ‘bar’})} в случае успеха, либо
{jsonrpc: ‘2.0’, error: errorThrown} в случае неудачи.

Из примера видно, как просто устроена система безопасности -- отсутствие метода в контексте генерирует ReferenceError, который просто отлавливается и возвращается как значение ключа error в ответе. Так же отлавливается и любое другое исключение, могущее возникнуть при выполнении вызванного метода.

Если тело POST-запроса не содержит ключа jsonrpc, то система работает в формате REST, при этом вызываемый метод контекста определяется глаголом HTTP, а URL определяет путь поиска метода в объекте контекста. Таким образом, обработка всех форматов web-интерфейса осуществляется одним методом.

POST /Foo {id: ID, foo: ‘bar’} === context.Foo.add({id: ID, foo: ‘bar’}) === POST {jsonrpc: ‘2.0’, method: [‘Foo’,’add’], params: [{id: ID, foo: ‘bar’}]}

GET /Foo?foo=bar === context.Foo.query(‘foo=bar’) === POST {jsonrpc: ‘2.0’, method: [‘Foo’,’query’], params: [‘foo=bar’]}

GET /Foo/ID === context.Foo.get(ID) === POST {jsonrpc: ‘2.0’, method: [‘Foo’,’get’], params: [ID]}

DELETE /Foo?foo=bar === context.Foo.remove(‘foo=bar’) === POST {jsonrpc: ‘2.0’, method: [‘Foo’,’remove’], params: [‘foo=bar’]}

POST /Foo?foo=bar {id: ID, foo: ‘baz’} === context.Foo.update(‘foo=bar’, {id: ID, foo: ‘baz’}) === POST {jsonrpc: ‘2.0’, method: [‘Foo’,’update’], params: [‘foo=bar’,{id: ID, foo: ‘baz’}]}

РОЛИ

Роль -- это фасет. Например, приведенный выше facet.admin -- это роль для администрирования Language.

Возможны более ограниченные роли, например:

role.iCanAddAndRemoveLanguages =
	Language:
		add: model.Language.add
remove: model.Language.remove

ГРУППЫ РОЛЕЙ

Группы ролей -- суперпозиция ролей. Крайне желательно, чтобы роли в группе не пересекались. В противном случае эффективный результат суперпозиции зависит от порядка ролей в группе, что вводит неопределенность.:

role.iCanReadRegions =
	Region:
		get: model.Region.get
		query: model.Region.query

group.iCanRemoveLanguagesAndICanReadRegions = merge
	role.iCanAddAndRemoveLanguages
	role.iCanReadRegions

Для текущей версии системы роли и группы должны прорабатываться одним человеком и задаваться жестко в исходных кодах системы.

Приведенная выше техника великолепно позволяет разграничивать доступ как к сущностям в целом, так и к отдельным атрибутам объектов и готова на 90%.

СУЩНОСТЬ User

Здесь есть сложности. Общие принципы, вне зависимости от привилегий пользователя:
user не может сам изменить свои права в системе
user не может читать частную информацию других user
user может дать другому как максимум только те права, что имеет сам
user может полностью управлять своим профилем


Получается, что один и тот же экземпляр сущности User должен быть виден различным пользователям по разному, в зависимости от текущего пользователя.

Для начала необходимо четко расписать карту атрибутов User и права доступа к ним:

		priv	self
id		cr	r
creator		Fr	r	# creator is immutable, or security fails
----- authority -----
active		rw	r
type		Fr	r	# type (Root,Aff,Merch,Admin) is immutable, or security fails
roles		rw	r
----- authentication -----
email		cr	rw	# MUST be, or nowhere to report unhashed password to
salt		c	rw	# should be chosen afresh so it;s not a vanilla update!
password	c	rw	# should be hashed before storing, so it;s not a vanilla update!
----- profile -----
name		r	rw
tz		r	rw
secret		-	rw	# to validate password recovery
…		r/-	rw

Макс, тебе ^^^^^


НИЖЕ НЕ СМОТРИМ









2011-01-25

- symmetric app: /Foo?a=b on server, /Foo#a=b on client -- my long-term dream! -- priority 99
- elaborate on schema attributes for UI -- updatable, visible -- client-side -- priority 2
- write generic secure add/update handler for data coming from web -- first to determine what properties are safe to take from the data coming! -- priority 0


N.B. if current user acts on record for _self_, his rights must be dropped for self -- that is, multi update must check for presense of self record in the recordset being updated!

update(q, changes) === [
model.User.update(q.ne(‘id’,@user.id), changes, schema.User.root)
model.User.update(q.eq(‘id’,@user.id), changes, schema.User.user)
]

N.B. a user is admin for its profile, but a reader for the rest

N.B. user can’t change his authority
N.B. user can give only what he’s got
N.B. creator is admin for his creatures



BUMP: DON’T KNOW HOW TO CODE SO FAR -- Priority 1


User =
	signup
	activate
	recover
	signin
	add
	query
	update
	remove? == update(,{active: false})
